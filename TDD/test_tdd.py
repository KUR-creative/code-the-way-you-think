# TDD의 경우 보통 테스트 코드를 다른 파일에 작성한다.
from test_driven import *

# 테스트를 먼저 작성한다.

# 어떤 테스트부터 해야할까?
# 가장 쉽고 뻔한 케이스부터 해야 한다.
# 또한 에러라고 생각되는 케이스부터 해야 한다.

# 고객이 준 돈이 < 상품 가격보다 작은 케이스를 생각해보자. 그럼 어쩌지?
# 거스름돈은 더 많이 낸 돈을 주는 것이다. 거스름돈은 없어야 맞겠다.
def test_cant_give_money():
    assert {} == change({50000: 2, 10000: 1, 10: 0}, 100, 10)
    # 1) test 이렇게 쓰고 테스트를 실행한다.
    # NameError를 보고 나면 change를 함수로 만든다.

    # 파이썬의 경우 AssertionError를 볼 때까지 짠다.
    # 다른 언어의 경우 컴파일 에러가 발생한다. 컴파일될 때까지 짠다.
    # 3) test

def test_normal_cases():
    # 6) more test
    # 학부생 코드에서 케이스들을 가져온다.
    assert {10: 0, 100: 0, 1000: 0, 10000: 0, 50000: 1} \
        == change({10: 0, 100: 0, 1000: 0, 10000: 1, 50000: 2},
                  50000, 100000)
    # 테스트한다. 실패한다. 이제 이 두 케이스를 모두 통과하는 코드를 짜야 한다.

    # TDD를 하면 이렇게 입출력을 먼저 쓰게 되고, assert를 쓰기 때문에
    # 일일히 확인하는 수고가 덜하고 실수가 줄어든다.

    # 7) 케이스를 더 추가한다.
    assert {10: 2, 100: 10, 1000: 0, 10000: 0, 50000: 0} \
        == change({50000: 0, 10000: 1, 1000: 0, 100: 10, 10: 2},
                  1000, 2020)
    # 물론 틀린다. 이제 어떻게 짤지 궁리한다.
    # 하나만 더 넣자.
    assert {10: 2, 100: 2, 1000: 1, 10000: 0, 50000: 0} \
        == change({50000: 10, 10000: 10, 1000: 10, 100: 10, 10: 10},
                  1120, 2340)
    # 테스트를 돌리면 실패한다.


'''
TDD는 사실 3가지가 섞인 방법론이다.
빠른 피드백 루프(작게 짜고 돌리기)
"작동하는" 스펙의 작성(예제를 통한 스펙)
테스팅(ㅇㅇ)

사실 사이클을 엄격하게 지키지 않아도 TDD는 맞다.
중요한 것은
1) 테스트를 먼저 생각 하는 것
2) 빠르게 실패하고 통과하게 하여 피드백을 받는 것
이다.
'''
